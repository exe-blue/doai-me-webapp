---
description: Command & Control 패턴 규칙 - 서버/노드 간 권한 분리
globs: ["apps/backend/**/*.js", "apps/backend/**/*.ts", "apps/desktop-agent/**/*.js"]
alwaysApply: true
---

# Command & Control 패턴 규칙

## 핵심 원칙

서버는 **Commander** (결정권자), 노드는 **Agent** (실행자)입니다.

## 서버 코드 규칙 (apps/backend)

### ✅ 허용

```javascript
// 상태 전이 결정은 서버만
await stateService.updateDeviceState(deviceId, trigger, context);

// 명령 발송
socket.emit('cmd:execute_workflow', { workflowId, deviceIds });
socket.emit('cmd:cancel_workflow', { executionId });
```

### ❌ 금지

```javascript
// 노드 이벤트를 서버가 emit하면 안됨
socket.emit('evt:heartbeat', { ... });  // ❌ evt:는 노드 전용
```

## 노드 코드 규칙 (apps/desktop-agent)

### ✅ 허용

```javascript
// 이벤트 보고만
socket.emit('evt:workflow_complete', { deviceId, result });
socket.emit('evt:workflow_failed', { deviceId, error });
socket.emit('evt:heartbeat', { nodeId, devices });

// 명령 수신
socket.on('cmd:execute_workflow', handler);
```

### ❌ 금지

```javascript
// 노드가 상태를 결정하면 안됨
socket.emit('evt:state_update', { state: 'IDLE' });  // ❌ 상태 결정 금지

// 서버 명령을 노드가 emit하면 안됨
socket.emit('cmd:reset_device', { ... });  // ❌ cmd:는 서버 전용
```

## 이벤트 네이밍

| Prefix | 방향 | 예시 |
|--------|------|------|
| `cmd:` | 서버 → 노드 | `cmd:execute_workflow` |
| `evt:` | 노드 → 서버 | `evt:workflow_complete` |

## 검증 질문

코드 작성 시 스스로 질문하세요:
1. "이 코드가 상태를 **결정**하는가, **보고**하는가?"
2. 노드 코드라면 → 보고만 해야 함
3. 서버 코드라면 → 결정 가능
